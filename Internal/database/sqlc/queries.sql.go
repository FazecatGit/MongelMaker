// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const addToWatchlist = `-- name: AddToWatchlist :one
INSERT INTO watchlist (symbol, asset_type, score, reason, added_date, last_updated, status)
VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 'active')
RETURNING id
`

type AddToWatchlistParams struct {
	Symbol    string         `json:"symbol"`
	AssetType string         `json:"asset_type"`
	Score     float32        `json:"score"`
	Reason    sql.NullString `json:"reason"`
}

// Add a new candidate to watchlist and return the ID
func (q *Queries) AddToWatchlist(ctx context.Context, arg AddToWatchlistParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, addToWatchlist,
		arg.Symbol,
		arg.AssetType,
		arg.Score,
		arg.Reason,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addWatchlistHistory = `-- name: AddWatchlistHistory :exec
INSERT INTO watchlist_history (watchlist_id, old_score, new_score, analysis_data, timestamp)
VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
`

type AddWatchlistHistoryParams struct {
	WatchlistID  int32           `json:"watchlist_id"`
	OldScore     sql.NullFloat64 `json:"old_score"`
	NewScore     float32         `json:"new_score"`
	AnalysisData sql.NullString  `json:"analysis_data"`
}

// Log score change with full analysis data (as JSON)
func (q *Queries) AddWatchlistHistory(ctx context.Context, arg AddWatchlistHistoryParams) error {
	_, err := q.db.ExecContext(ctx, addWatchlistHistory,
		arg.WatchlistID,
		arg.OldScore,
		arg.NewScore,
		arg.AnalysisData,
	)
	return err
}

const archiveOldWatchlist = `-- name: ArchiveOldWatchlist :exec
UPDATE watchlist
SET status = 'archived'
WHERE id IN (
  SELECT w.id FROM watchlist w
  WHERE w.status = 'active'
  AND datetime(w.last_updated) < datetime('now', '-30 days')
)
`

// Archive symbols with unchanged score for 30+ days
func (q *Queries) ArchiveOldWatchlist(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, archiveOldWatchlist)
	return err
}

const createWhaleEvent = `-- name: CreateWhaleEvent :exec
INSERT INTO whale_events (
    symbol, timestamp, direction, volume, z_score, close_price, price_change, conviction
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateWhaleEventParams struct {
	Symbol      string         `json:"symbol"`
	Timestamp   time.Time      `json:"timestamp"`
	Direction   string         `json:"direction"`
	Volume      int64          `json:"volume"`
	ZScore      string         `json:"z_score"`
	ClosePrice  string         `json:"close_price"`
	PriceChange sql.NullString `json:"price_change"`
	Conviction  string         `json:"conviction"`
}

func (q *Queries) CreateWhaleEvent(ctx context.Context, arg CreateWhaleEventParams) error {
	_, err := q.db.ExecContext(ctx, createWhaleEvent,
		arg.Symbol,
		arg.Timestamp,
		arg.Direction,
		arg.Volume,
		arg.ZScore,
		arg.ClosePrice,
		arg.PriceChange,
		arg.Conviction,
	)
	return err
}

const getATR = `-- name: GetATR :one
SELECT atr_value, calculation_timestamp
FROM atr_calculation
WHERE symbol = $1
ORDER BY calculation_timestamp DESC
LIMIT 1
`

type GetATRRow struct {
	AtrValue             float32   `json:"atr_value"`
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
}

func (q *Queries) GetATR(ctx context.Context, symbol string) (GetATRRow, error) {
	row := q.db.QueryRowContext(ctx, getATR, symbol)
	var i GetATRRow
	err := row.Scan(&i.AtrValue, &i.CalculationTimestamp)
	return i, err
}

const getATRByTimestampRange = `-- name: GetATRByTimestampRange :many
SELECT calculation_timestamp, atr_value
FROM atr_calculation
WHERE symbol = $1
  AND calculation_timestamp >= $2
  AND calculation_timestamp <= $3
ORDER BY calculation_timestamp ASC
`

type GetATRByTimestampRangeParams struct {
	Symbol                 string    `json:"symbol"`
	CalculationTimestamp   time.Time `json:"calculation_timestamp"`
	CalculationTimestamp_2 time.Time `json:"calculation_timestamp_2"`
}

type GetATRByTimestampRangeRow struct {
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	AtrValue             float32   `json:"atr_value"`
}

func (q *Queries) GetATRByTimestampRange(ctx context.Context, arg GetATRByTimestampRangeParams) ([]GetATRByTimestampRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getATRByTimestampRange, arg.Symbol, arg.CalculationTimestamp, arg.CalculationTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetATRByTimestampRangeRow
	for rows.Next() {
		var i GetATRByTimestampRangeRow
		if err := rows.Scan(&i.CalculationTimestamp, &i.AtrValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getATRForDateRange = `-- name: GetATRForDateRange :many
SELECT calculation_timestamp, atr_value
FROM atr_calculation
WHERE symbol = $1
ORDER BY calculation_timestamp DESC
LIMIT $2
`

type GetATRForDateRangeParams struct {
	Symbol string `json:"symbol"`
	Limit  int32  `json:"limit"`
}

type GetATRForDateRangeRow struct {
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	AtrValue             float32   `json:"atr_value"`
}

func (q *Queries) GetATRForDateRange(ctx context.Context, arg GetATRForDateRangeParams) ([]GetATRForDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getATRForDateRange, arg.Symbol, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetATRForDateRangeRow
	for rows.Next() {
		var i GetATRForDateRangeRow
		if err := rows.Scan(&i.CalculationTimestamp, &i.AtrValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getATRPrices = `-- name: GetATRPrices :many
SELECT high_price, low_price, close_price, timestamp
FROM historical_bars
WHERE symbol = $1 
  AND timeframe = $2
ORDER BY timestamp ASC
LIMIT $3
`

type GetATRPricesParams struct {
	Symbol    string `json:"symbol"`
	Timeframe string `json:"timeframe"`
	Limit     int32  `json:"limit"`
}

type GetATRPricesRow struct {
	HighPrice  string    `json:"high_price"`
	LowPrice   string    `json:"low_price"`
	ClosePrice string    `json:"close_price"`
	Timestamp  time.Time `json:"timestamp"`
}

func (q *Queries) GetATRPrices(ctx context.Context, arg GetATRPricesParams) ([]GetATRPricesRow, error) {
	rows, err := q.db.QueryContext(ctx, getATRPrices, arg.Symbol, arg.Timeframe, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetATRPricesRow
	for rows.Next() {
		var i GetATRPricesRow
		if err := rows.Scan(
			&i.HighPrice,
			&i.LowPrice,
			&i.ClosePrice,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllScanLogs = `-- name: GetAllScanLogs :many
SELECT id, profile_name, last_scan_timestamp, next_scan_due, symbols_scanned
FROM scan_log
ORDER BY profile_name
`

type GetAllScanLogsRow struct {
	ID                int32         `json:"id"`
	ProfileName       string        `json:"profile_name"`
	LastScanTimestamp time.Time     `json:"last_scan_timestamp"`
	NextScanDue       time.Time     `json:"next_scan_due"`
	SymbolsScanned    sql.NullInt32 `json:"symbols_scanned"`
}

// Get all scan log entries
func (q *Queries) GetAllScanLogs(ctx context.Context) ([]GetAllScanLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllScanLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllScanLogsRow
	for rows.Next() {
		var i GetAllScanLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileName,
			&i.LastScanTimestamp,
			&i.NextScanDue,
			&i.SymbolsScanned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClosingPrices = `-- name: GetClosingPrices :many
SELECT close_price, timestamp
FROM historical_bars
WHERE symbol = $1 
  AND timeframe = $2
ORDER BY timestamp ASC
LIMIT $3
`

type GetClosingPricesParams struct {
	Symbol    string `json:"symbol"`
	Timeframe string `json:"timeframe"`
	Limit     int32  `json:"limit"`
}

type GetClosingPricesRow struct {
	ClosePrice string    `json:"close_price"`
	Timestamp  time.Time `json:"timestamp"`
}

func (q *Queries) GetClosingPrices(ctx context.Context, arg GetClosingPricesParams) ([]GetClosingPricesRow, error) {
	rows, err := q.db.QueryContext(ctx, getClosingPrices, arg.Symbol, arg.Timeframe, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClosingPricesRow
	for rows.Next() {
		var i GetClosingPricesRow
		if err := rows.Scan(&i.ClosePrice, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighConvictionWhales = `-- name: GetHighConvictionWhales :many
SELECT id, symbol, timestamp, direction, volume, z_score, close_price, price_change, conviction, created_at FROM whale_events
WHERE symbol = $1 AND conviction = 'HIGH'
ORDER BY z_score DESC
LIMIT 10
`

func (q *Queries) GetHighConvictionWhales(ctx context.Context, symbol string) ([]WhaleEvent, error) {
	rows, err := q.db.QueryContext(ctx, getHighConvictionWhales, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WhaleEvent
	for rows.Next() {
		var i WhaleEvent
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Timestamp,
			&i.Direction,
			&i.Volume,
			&i.ZScore,
			&i.ClosePrice,
			&i.PriceChange,
			&i.Conviction,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNews = `-- name: GetLatestNews :many
SELECT id, symbol, headline, url, published_at, source, sentiment, created_at
FROM news_articles
WHERE symbol = $1
ORDER BY published_at DESC
LIMIT $2
`

type GetLatestNewsParams struct {
	Symbol string `json:"symbol"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetLatestNews(ctx context.Context, arg GetLatestNewsParams) ([]NewsArticle, error) {
	rows, err := q.db.QueryContext(ctx, getLatestNews, arg.Symbol, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Headline,
			&i.Url,
			&i.PublishedAt,
			&i.Source,
			&i.Sentiment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestRSI = `-- name: GetLatestRSI :one
SELECT rsi_value, calculation_timestamp
FROM rsi_calculation
WHERE symbol = $1
ORDER BY calculation_timestamp DESC
LIMIT 1
`

type GetLatestRSIRow struct {
	RsiValue             float32   `json:"rsi_value"`
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
}

func (q *Queries) GetLatestRSI(ctx context.Context, symbol string) (GetLatestRSIRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestRSI, symbol)
	var i GetLatestRSIRow
	err := row.Scan(&i.RsiValue, &i.CalculationTimestamp)
	return i, err
}

const getNewsBySymbol = `-- name: GetNewsBySymbol :many
SELECT id, symbol, headline, url, published_at, source, sentiment, created_at
FROM news_articles
WHERE symbol = $1
AND published_at > NOW() - INTERVAL '7 days'
ORDER BY published_at DESC
`

func (q *Queries) GetNewsBySymbol(ctx context.Context, symbol string) ([]NewsArticle, error) {
	rows, err := q.db.QueryContext(ctx, getNewsBySymbol, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Headline,
			&i.Url,
			&i.PublishedAt,
			&i.Source,
			&i.Sentiment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsForScreener = `-- name: GetNewsForScreener :many
SELECT id, symbol, headline, url, published_at, source, sentiment, created_at
FROM news_articles
WHERE symbol = ANY($1::text[])
ORDER BY published_at DESC
`

func (q *Queries) GetNewsForScreener(ctx context.Context, dollar_1 []string) ([]NewsArticle, error) {
	rows, err := q.db.QueryContext(ctx, getNewsForScreener, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Headline,
			&i.Url,
			&i.PublishedAt,
			&i.Source,
			&i.Sentiment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSIByTimestampRange = `-- name: GetRSIByTimestampRange :many
SELECT calculation_timestamp, rsi_value
FROM rsi_calculation
WHERE symbol = $1
  AND calculation_timestamp >= $2
  AND calculation_timestamp <= $3
ORDER BY calculation_timestamp ASC
`

type GetRSIByTimestampRangeParams struct {
	Symbol                 string    `json:"symbol"`
	CalculationTimestamp   time.Time `json:"calculation_timestamp"`
	CalculationTimestamp_2 time.Time `json:"calculation_timestamp_2"`
}

type GetRSIByTimestampRangeRow struct {
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	RsiValue             float32   `json:"rsi_value"`
}

func (q *Queries) GetRSIByTimestampRange(ctx context.Context, arg GetRSIByTimestampRangeParams) ([]GetRSIByTimestampRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getRSIByTimestampRange, arg.Symbol, arg.CalculationTimestamp, arg.CalculationTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRSIByTimestampRangeRow
	for rows.Next() {
		var i GetRSIByTimestampRangeRow
		if err := rows.Scan(&i.CalculationTimestamp, &i.RsiValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSIForDateRange = `-- name: GetRSIForDateRange :many
SELECT calculation_timestamp, rsi_value
FROM rsi_calculation
WHERE symbol = $1
ORDER BY calculation_timestamp DESC
LIMIT $2
`

type GetRSIForDateRangeParams struct {
	Symbol string `json:"symbol"`
	Limit  int32  `json:"limit"`
}

type GetRSIForDateRangeRow struct {
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	RsiValue             float32   `json:"rsi_value"`
}

func (q *Queries) GetRSIForDateRange(ctx context.Context, arg GetRSIForDateRangeParams) ([]GetRSIForDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getRSIForDateRange, arg.Symbol, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRSIForDateRangeRow
	for rows.Next() {
		var i GetRSIForDateRangeRow
		if err := rows.Scan(&i.CalculationTimestamp, &i.RsiValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecheckableSymbols = `-- name: GetRecheckableSymbols :many
SELECT symbol, asset_type, reason FROM skip_backlog
WHERE recheck_after <= CURRENT_TIMESTAMP
`

type GetRecheckableSymbolsRow struct {
	Symbol    string         `json:"symbol"`
	AssetType string         `json:"asset_type"`
	Reason    sql.NullString `json:"reason"`
}

// Get symbols from skip backlog that are ready for reconsideration
func (q *Queries) GetRecheckableSymbols(ctx context.Context) ([]GetRecheckableSymbolsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecheckableSymbols)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecheckableSymbolsRow
	for rows.Next() {
		var i GetRecheckableSymbolsRow
		if err := rows.Scan(&i.Symbol, &i.AssetType, &i.Reason); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScanLog = `-- name: GetScanLog :one

SELECT id, profile_name, last_scan_timestamp, next_scan_due, symbols_scanned
FROM scan_log
WHERE profile_name = $1
`

type GetScanLogRow struct {
	ID                int32         `json:"id"`
	ProfileName       string        `json:"profile_name"`
	LastScanTimestamp time.Time     `json:"last_scan_timestamp"`
	NextScanDue       time.Time     `json:"next_scan_due"`
	SymbolsScanned    sql.NullInt32 `json:"symbols_scanned"`
}

// Scan Log Queries
// Get the latest scan log entry for a profile
func (q *Queries) GetScanLog(ctx context.Context, profileName string) (GetScanLogRow, error) {
	row := q.db.QueryRowContext(ctx, getScanLog, profileName)
	var i GetScanLogRow
	err := row.Scan(
		&i.ID,
		&i.ProfileName,
		&i.LastScanTimestamp,
		&i.NextScanDue,
		&i.SymbolsScanned,
	)
	return i, err
}

const getWatchlist = `-- name: GetWatchlist :many
SELECT id, symbol, asset_type, score, reason, added_date, last_updated
FROM watchlist
WHERE status = 'active'
ORDER BY score DESC
`

type GetWatchlistRow struct {
	ID          int32          `json:"id"`
	Symbol      string         `json:"symbol"`
	AssetType   string         `json:"asset_type"`
	Score       float32        `json:"score"`
	Reason      sql.NullString `json:"reason"`
	AddedDate   sql.NullTime   `json:"added_date"`
	LastUpdated sql.NullTime   `json:"last_updated"`
}

// Get all active watchlist items, ordered by score
func (q *Queries) GetWatchlist(ctx context.Context) ([]GetWatchlistRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchlist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchlistRow
	for rows.Next() {
		var i GetWatchlistRow
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.AssetType,
			&i.Score,
			&i.Reason,
			&i.AddedDate,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchlistBySymbol = `-- name: GetWatchlistBySymbol :one
SELECT id, symbol, asset_type, score, reason, added_date, last_updated
FROM watchlist
WHERE symbol = $1 AND status = 'active'
`

type GetWatchlistBySymbolRow struct {
	ID          int32          `json:"id"`
	Symbol      string         `json:"symbol"`
	AssetType   string         `json:"asset_type"`
	Score       float32        `json:"score"`
	Reason      sql.NullString `json:"reason"`
	AddedDate   sql.NullTime   `json:"added_date"`
	LastUpdated sql.NullTime   `json:"last_updated"`
}

// Get a watchlist item by symbol
func (q *Queries) GetWatchlistBySymbol(ctx context.Context, symbol string) (GetWatchlistBySymbolRow, error) {
	row := q.db.QueryRowContext(ctx, getWatchlistBySymbol, symbol)
	var i GetWatchlistBySymbolRow
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.AssetType,
		&i.Score,
		&i.Reason,
		&i.AddedDate,
		&i.LastUpdated,
	)
	return i, err
}

const getWhaleEventsBySymbol = `-- name: GetWhaleEventsBySymbol :many
SELECT id, symbol, timestamp, direction, volume, z_score, close_price, price_change, conviction, created_at FROM whale_events
WHERE symbol = $1 AND timestamp > NOW() - INTERVAL '7 days'
ORDER BY timestamp DESC
LIMIT $2
`

type GetWhaleEventsBySymbolParams struct {
	Symbol string `json:"symbol"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetWhaleEventsBySymbol(ctx context.Context, arg GetWhaleEventsBySymbolParams) ([]WhaleEvent, error) {
	rows, err := q.db.QueryContext(ctx, getWhaleEventsBySymbol, arg.Symbol, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WhaleEvent
	for rows.Next() {
		var i WhaleEvent
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Timestamp,
			&i.Direction,
			&i.Volume,
			&i.ZScore,
			&i.ClosePrice,
			&i.PriceChange,
			&i.Conviction,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFromSkipBacklog = `-- name: RemoveFromSkipBacklog :exec
DELETE FROM skip_backlog WHERE symbol = $1
`

// Remove symbol from skip backlog after rechecking
func (q *Queries) RemoveFromSkipBacklog(ctx context.Context, symbol string) error {
	_, err := q.db.ExecContext(ctx, removeFromSkipBacklog, symbol)
	return err
}

const saveATR = `-- name: SaveATR :exec
INSERT INTO atr_calculation (symbol, calculation_timestamp, atr_value)
VALUES ($1, $2, $3)
ON CONFLICT (symbol, calculation_timestamp)
DO UPDATE SET atr_value = EXCLUDED.atr_value
`

type SaveATRParams struct {
	Symbol               string    `json:"symbol"`
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	AtrValue             float32   `json:"atr_value"`
}

func (q *Queries) SaveATR(ctx context.Context, arg SaveATRParams) error {
	_, err := q.db.ExecContext(ctx, saveATR, arg.Symbol, arg.CalculationTimestamp, arg.AtrValue)
	return err
}

const saveNewsArticle = `-- name: SaveNewsArticle :exec
INSERT INTO news_articles (symbol, headline, url, published_at, source, sentiment)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (url) DO NOTHING
`

type SaveNewsArticleParams struct {
	Symbol      string         `json:"symbol"`
	Headline    string         `json:"headline"`
	Url         string         `json:"url"`
	PublishedAt time.Time      `json:"published_at"`
	Source      sql.NullString `json:"source"`
	Sentiment   sql.NullString `json:"sentiment"`
}

func (q *Queries) SaveNewsArticle(ctx context.Context, arg SaveNewsArticleParams) error {
	_, err := q.db.ExecContext(ctx, saveNewsArticle,
		arg.Symbol,
		arg.Headline,
		arg.Url,
		arg.PublishedAt,
		arg.Source,
		arg.Sentiment,
	)
	return err
}

const saveRSI = `-- name: SaveRSI :exec
INSERT INTO rsi_calculation (symbol, calculation_timestamp, rsi_value)
VALUES ($1, $2, $3)
ON CONFLICT (symbol, calculation_timestamp)
DO UPDATE SET rsi_value = EXCLUDED.rsi_value
`

type SaveRSIParams struct {
	Symbol               string    `json:"symbol"`
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	RsiValue             float32   `json:"rsi_value"`
}

func (q *Queries) SaveRSI(ctx context.Context, arg SaveRSIParams) error {
	_, err := q.db.ExecContext(ctx, saveRSI, arg.Symbol, arg.CalculationTimestamp, arg.RsiValue)
	return err
}

const skipSymbol = `-- name: SkipSymbol :exec
INSERT INTO skip_backlog (symbol, asset_type, reason, timestamp, recheck_after)
VALUES ($1, $2, $3, CURRENT_TIMESTAMP, datetime('now', '+30 days'))
`

type SkipSymbolParams struct {
	Symbol    string         `json:"symbol"`
	AssetType string         `json:"asset_type"`
	Reason    sql.NullString `json:"reason"`
}

// Add to skip backlog (recheck in 30 days)
func (q *Queries) SkipSymbol(ctx context.Context, arg SkipSymbolParams) error {
	_, err := q.db.ExecContext(ctx, skipSymbol, arg.Symbol, arg.AssetType, arg.Reason)
	return err
}

const updateWatchlistScore = `-- name: UpdateWatchlistScore :exec
UPDATE watchlist
SET score = $1, last_updated = CURRENT_TIMESTAMP
WHERE symbol = $2
`

type UpdateWatchlistScoreParams struct {
	Score  float32 `json:"score"`
	Symbol string  `json:"symbol"`
}

// Update score and add history entry
func (q *Queries) UpdateWatchlistScore(ctx context.Context, arg UpdateWatchlistScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateWatchlistScore, arg.Score, arg.Symbol)
	return err
}

const upsertScanLog = `-- name: UpsertScanLog :exec
INSERT INTO scan_log (profile_name, last_scan_timestamp, next_scan_due, symbols_scanned)
VALUES ($1, $2, $3, $4)
ON CONFLICT (profile_name) DO UPDATE SET
    last_scan_timestamp = EXCLUDED.last_scan_timestamp,
    next_scan_due = EXCLUDED.next_scan_due,
    symbols_scanned = EXCLUDED.symbols_scanned,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertScanLogParams struct {
	ProfileName       string        `json:"profile_name"`
	LastScanTimestamp time.Time     `json:"last_scan_timestamp"`
	NextScanDue       time.Time     `json:"next_scan_due"`
	SymbolsScanned    sql.NullInt32 `json:"symbols_scanned"`
}

// Insert or update scan log entry
func (q *Queries) UpsertScanLog(ctx context.Context, arg UpsertScanLogParams) error {
	_, err := q.db.ExecContext(ctx, upsertScanLog,
		arg.ProfileName,
		arg.LastScanTimestamp,
		arg.NextScanDue,
		arg.SymbolsScanned,
	)
	return err
}
