// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const getATR = `-- name: GetATR :one
SELECT atr_value, calculation_timestamp
FROM atr_calculation
WHERE symbol = $1
ORDER BY calculation_timestamp DESC
LIMIT 1
`

type GetATRRow struct {
	AtrValue             string    `json:"atr_value"`
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
}

func (q *Queries) GetATR(ctx context.Context, symbol string) (GetATRRow, error) {
	row := q.db.QueryRowContext(ctx, getATR, symbol)
	var i GetATRRow
	err := row.Scan(&i.AtrValue, &i.CalculationTimestamp)
	return i, err
}

const getATRByTimestampRange = `-- name: GetATRByTimestampRange :many
SELECT calculation_timestamp, atr_value
FROM atr_calculation
WHERE symbol = $1
  AND calculation_timestamp >= $2
  AND calculation_timestamp <= $3
ORDER BY calculation_timestamp ASC
`

type GetATRByTimestampRangeParams struct {
	Symbol                 string    `json:"symbol"`
	CalculationTimestamp   time.Time `json:"calculation_timestamp"`
	CalculationTimestamp_2 time.Time `json:"calculation_timestamp_2"`
}

type GetATRByTimestampRangeRow struct {
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	AtrValue             string    `json:"atr_value"`
}

func (q *Queries) GetATRByTimestampRange(ctx context.Context, arg GetATRByTimestampRangeParams) ([]GetATRByTimestampRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getATRByTimestampRange, arg.Symbol, arg.CalculationTimestamp, arg.CalculationTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetATRByTimestampRangeRow
	for rows.Next() {
		var i GetATRByTimestampRangeRow
		if err := rows.Scan(&i.CalculationTimestamp, &i.AtrValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getATRForDateRange = `-- name: GetATRForDateRange :many
SELECT calculation_timestamp, atr_value
FROM atr_calculation
WHERE symbol = $1
ORDER BY calculation_timestamp DESC
LIMIT $2
`

type GetATRForDateRangeParams struct {
	Symbol string `json:"symbol"`
	Limit  int32  `json:"limit"`
}

type GetATRForDateRangeRow struct {
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	AtrValue             string    `json:"atr_value"`
}

func (q *Queries) GetATRForDateRange(ctx context.Context, arg GetATRForDateRangeParams) ([]GetATRForDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getATRForDateRange, arg.Symbol, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetATRForDateRangeRow
	for rows.Next() {
		var i GetATRForDateRangeRow
		if err := rows.Scan(&i.CalculationTimestamp, &i.AtrValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getATRPrices = `-- name: GetATRPrices :many
SELECT high_price, low_price, close_price, timestamp
FROM historical_bars
WHERE symbol = $1 
  AND timeframe = $2
ORDER BY timestamp ASC
LIMIT $3
`

type GetATRPricesParams struct {
	Symbol    string `json:"symbol"`
	Timeframe string `json:"timeframe"`
	Limit     int32  `json:"limit"`
}

type GetATRPricesRow struct {
	HighPrice  string    `json:"high_price"`
	LowPrice   string    `json:"low_price"`
	ClosePrice string    `json:"close_price"`
	Timestamp  time.Time `json:"timestamp"`
}

func (q *Queries) GetATRPrices(ctx context.Context, arg GetATRPricesParams) ([]GetATRPricesRow, error) {
	rows, err := q.db.QueryContext(ctx, getATRPrices, arg.Symbol, arg.Timeframe, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetATRPricesRow
	for rows.Next() {
		var i GetATRPricesRow
		if err := rows.Scan(
			&i.HighPrice,
			&i.LowPrice,
			&i.ClosePrice,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClosingPrices = `-- name: GetClosingPrices :many
SELECT close_price, timestamp
FROM historical_bars
WHERE symbol = $1 
  AND timeframe = $2
ORDER BY timestamp ASC
LIMIT $3
`

type GetClosingPricesParams struct {
	Symbol    string `json:"symbol"`
	Timeframe string `json:"timeframe"`
	Limit     int32  `json:"limit"`
}

type GetClosingPricesRow struct {
	ClosePrice string    `json:"close_price"`
	Timestamp  time.Time `json:"timestamp"`
}

func (q *Queries) GetClosingPrices(ctx context.Context, arg GetClosingPricesParams) ([]GetClosingPricesRow, error) {
	rows, err := q.db.QueryContext(ctx, getClosingPrices, arg.Symbol, arg.Timeframe, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClosingPricesRow
	for rows.Next() {
		var i GetClosingPricesRow
		if err := rows.Scan(&i.ClosePrice, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNews = `-- name: GetLatestNews :many
SELECT id, symbol, headline, url, published_at, source, sentiment, created_at
FROM news_articles
WHERE symbol = $1
ORDER BY published_at DESC
LIMIT $2
`

type GetLatestNewsParams struct {
	Symbol string `json:"symbol"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetLatestNews(ctx context.Context, arg GetLatestNewsParams) ([]NewsArticle, error) {
	rows, err := q.db.QueryContext(ctx, getLatestNews, arg.Symbol, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Headline,
			&i.Url,
			&i.PublishedAt,
			&i.Source,
			&i.Sentiment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestRSI = `-- name: GetLatestRSI :one
SELECT rsi_value, calculation_timestamp
FROM rsi_calculation
WHERE symbol = $1
ORDER BY calculation_timestamp DESC
LIMIT 1
`

type GetLatestRSIRow struct {
	RsiValue             string    `json:"rsi_value"`
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
}

func (q *Queries) GetLatestRSI(ctx context.Context, symbol string) (GetLatestRSIRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestRSI, symbol)
	var i GetLatestRSIRow
	err := row.Scan(&i.RsiValue, &i.CalculationTimestamp)
	return i, err
}

const getNewsForScreener = `-- name: GetNewsForScreener :many
SELECT id, symbol, headline, url, published_at, source, sentiment, created_at
FROM news_articles
WHERE symbol = ANY($1::text[])
AND published_at > NOW() - INTERVAL '7 days'
ORDER BY published_at DESC
`

func (q *Queries) GetNewsForScreener(ctx context.Context, symbols []string) ([]NewsArticle, error) {
	rows, err := q.db.QueryContext(ctx, getNewsForScreener, pq.Array(symbols))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Headline,
			&i.Url,
			&i.PublishedAt,
			&i.Source,
			&i.Sentiment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSIByTimestampRange = `-- name: GetRSIByTimestampRange :many
SELECT calculation_timestamp, rsi_value
FROM rsi_calculation
WHERE symbol = $1
  AND calculation_timestamp >= $2
  AND calculation_timestamp <= $3
ORDER BY calculation_timestamp ASC
`

type GetRSIByTimestampRangeParams struct {
	Symbol                 string    `json:"symbol"`
	CalculationTimestamp   time.Time `json:"calculation_timestamp"`
	CalculationTimestamp_2 time.Time `json:"calculation_timestamp_2"`
}

type GetRSIByTimestampRangeRow struct {
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	RsiValue             string    `json:"rsi_value"`
}

func (q *Queries) GetRSIByTimestampRange(ctx context.Context, arg GetRSIByTimestampRangeParams) ([]GetRSIByTimestampRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getRSIByTimestampRange, arg.Symbol, arg.CalculationTimestamp, arg.CalculationTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRSIByTimestampRangeRow
	for rows.Next() {
		var i GetRSIByTimestampRangeRow
		if err := rows.Scan(&i.CalculationTimestamp, &i.RsiValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSIForDateRange = `-- name: GetRSIForDateRange :many
SELECT calculation_timestamp, rsi_value
FROM rsi_calculation
WHERE symbol = $1
ORDER BY calculation_timestamp DESC
LIMIT $2
`

type GetRSIForDateRangeParams struct {
	Symbol string `json:"symbol"`
	Limit  int32  `json:"limit"`
}

type GetRSIForDateRangeRow struct {
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	RsiValue             string    `json:"rsi_value"`
}

func (q *Queries) GetRSIForDateRange(ctx context.Context, arg GetRSIForDateRangeParams) ([]GetRSIForDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getRSIForDateRange, arg.Symbol, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRSIForDateRangeRow
	for rows.Next() {
		var i GetRSIForDateRangeRow
		if err := rows.Scan(&i.CalculationTimestamp, &i.RsiValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveATR = `-- name: SaveATR :exec
INSERT INTO atr_calculation (symbol, calculation_timestamp, atr_value)
VALUES ($1, $2, $3)
ON CONFLICT (symbol, calculation_timestamp)
DO UPDATE SET atr_value = EXCLUDED.atr_value
`

type SaveATRParams struct {
	Symbol               string    `json:"symbol"`
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	AtrValue             string    `json:"atr_value"`
}

func (q *Queries) SaveATR(ctx context.Context, arg SaveATRParams) error {
	_, err := q.db.ExecContext(ctx, saveATR, arg.Symbol, arg.CalculationTimestamp, arg.AtrValue)
	return err
}

const saveNewsArticle = `-- name: SaveNewsArticle :exec
INSERT INTO news_articles (symbol, headline, url, published_at, source, sentiment)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (url) DO NOTHING
`

type SaveNewsArticleParams struct {
	Symbol      string         `json:"symbol"`
	Headline    string         `json:"headline"`
	Url         string         `json:"url"`
	PublishedAt time.Time      `json:"published_at"`
	Source      sql.NullString `json:"source"`
	Sentiment   sql.NullString `json:"sentiment"`
}

func (q *Queries) SaveNewsArticle(ctx context.Context, arg SaveNewsArticleParams) error {
	_, err := q.db.ExecContext(ctx, saveNewsArticle,
		arg.Symbol,
		arg.Headline,
		arg.Url,
		arg.PublishedAt,
		arg.Source,
		arg.Sentiment,
	)
	return err
}

const saveRSI = `-- name: SaveRSI :exec
INSERT INTO rsi_calculation (symbol, calculation_timestamp, rsi_value)
VALUES ($1, $2, $3)
ON CONFLICT (symbol, calculation_timestamp)
DO UPDATE SET rsi_value = EXCLUDED.rsi_value
`

type SaveRSIParams struct {
	Symbol               string    `json:"symbol"`
	CalculationTimestamp time.Time `json:"calculation_timestamp"`
	RsiValue             string    `json:"rsi_value"`
}

func (q *Queries) SaveRSI(ctx context.Context, arg SaveRSIParams) error {
	_, err := q.db.ExecContext(ctx, saveRSI, arg.Symbol, arg.CalculationTimestamp, arg.RsiValue)
	return err
}
